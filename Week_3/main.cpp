/************************************************************************
 * @file  main.cpp
 * 
 * @brief The main function for the analysis homework project. This file
 * contains the main function that calls various analysis functions and
 * writes their results to text files.
 ************************************************************************/

#include <iostream>
#include <fstream>
#include <ctime>

using namespace std;

// Function prototypes
int getMiddleElement(int* arr, int size, unsigned int& counter);
int findRange(int* arr, int size, unsigned int& counter);
unsigned long powerOfN(int base, int exponent, unsigned int& counter);
int findMaxInMatrix(int** matrix, int N, unsigned int& counter);
unsigned long long factorial(unsigned int n, unsigned int& counter);
bool isPrime(unsigned int N, unsigned int& counter);
bool hasDuplicates(int* arr, int size, unsigned int& counter);

// Main function
int main() {
    const unsigned LIMIT = 100; /**< The # of times to run the experiments. */
    srand(static_cast<unsigned int>(time(0))); // Seed the random number generator

    /**
     * Call each function and write the results to text files
     */
    ofstream constantTimeFile("Middle.txt");
    ofstream linearTimeFile("Range.txt");
    ofstream linearExpFile("PowerofN.txt");
    ofstream quadraticTimeFile("Matrix.txt");
    ofstream factorialFile("Factorial.txt");
    ofstream primeFile("Prime.txt");
    ofstream duplicatesFile("Duplicates.txt");  

    for(int i = 0; i < LIMIT; i++) {
        // 1. Middle - Constant
        unsigned int counter {0}; // Counter for operations
        int size = i+1; // Size of the array, to account for 0 at the start
        int* arr = new int[i]; // Allocate an array of size i
        for(int j = 0; j < size; j++) {
            arr[j] = rand() % 100; // Fill the array with random integers
        }
        int result = getMiddleElement(arr, size, counter);
        constantTimeFile << i << " " << counter << " result: " << result << "\n";

        // 2. Range - Linear
        counter = 0;
        result = findRange(arr, size, counter);
        linearTimeFile << i << " " << counter << " result: " << result << "\n";

        // 3. Power of N - Linear exponential
        counter = 0;
        result = powerOfN(2, i, counter);
        linearExpFile << i << " " << counter << " result: " << result << "\n";

        // 4. Matrix - quadratic
        counter = 0;
        int** matrix = new int*[size];
        for(int j = 0; j < size; j++) {
            matrix[j] = new int[i];
        }
        for(int r = 0; r < size; r++) {
            for(int c = 0; c < i; c++) {
                matrix[r][c] = rand() % 100; // Fill the matrix with random integers
            }
        }
        result = findMaxInMatrix(matrix, size, counter);
        quadraticTimeFile << i << " " << counter << " result: " << result << "\n";
        for(int j = 0; j < size; j++){
            delete[] matrix[j];
        }
        delete[] matrix;

        // 5. Factorial - linear
        counter = 0;
        unsigned long long fact = factorial(i, counter);
        factorialFile << i << " " << counter << " result: " << result << "\n";

        // 6. Prime - linear (or better?)
        counter = 0;
        bool prime = isPrime(i, counter);
        primeFile << i << " " << counter << " result: " << result << "\n";

        // 7. Duplicates - quadratic
        counter = 0;
        bool duplicates = hasDuplicates(arr, size, counter);
        duplicatesFile << i << " " << counter << " result: " << result << "\n";
        delete[] arr;
    }
    return 0;
}

/** 
 * @brief Finds the middle element of an array.
 * 
 * @param arr The array of integers.
 * @return int The middle element of the array.
 *
 * 1. Constant Time – Array Middle Element: Write a C++ function that takes an 
 * array of integers and returns the middle element. Analyze the time complexity 
 * and discuss why it is O(1). Ensure that the plot aligns with constant time.
 */
int getMiddleElement(int* arr, int size, unsigned int& counter) {
    counter++; // Increment counter for the operation
    return arr[size / 2]; // Return the middle element
}

/** 
 * @brief Finds the range of elements in an array.
 * 
 * @param arr The array of integers.
 * @param size The size of the array.
 * @return int The range of the array (max - min).
 * 
 * 2. Linear Time – Array Range: Implement a function to find the range of all 
 * elements in an array of integers using a loop. Analyze its time complexity 
 * and discuss why it is O(n). Ensure that the plot aligns with linear time.
 * 
 * Function generated by Copilot 09/10/2025, edited by Alex Burdick
 */
int findRange(int* arr, int size, unsigned int& counter) {
    if (size <= 0) return 0; // Handle empty array case

    int min = arr[0]; /**< Holder for the smallest number. */
    int max = arr[0]; /**< Holder for the largetst number */

    for (int i = 1; i < size; i++) {        // Loop through the array and set 
        if (arr[i] < min) { min = arr[i]; } // the min and max, starting at 1
        if (arr[i] > max) { max = arr[i]; } // because we already set min and 
        counter++;                          // max to arr[0]
    }                                       

    return max - min; // Return the range
}

/**
 * @brief Calculates the power of a number using iterative multiplication.
 * 
 * 3. Linear Time - Exponential Function: Implement an iterative function to 
 * calculate the result of raising a number to a power (e.g., x^n). Do not use 
 * any library exponentiation, use brute force iterative multiplication. 
 * Analyze and discuss its time complexity. Ensure that the plot aligns with 
 * your conclusions.
 */
unsigned long powerOfN(int base, int exponent, unsigned int& counter) {
    unsigned long power = base; /**< Holds the power to return */
    for (int i = 2; i <= exponent; i++) { // Start at 2, we already have base^1
        power *= base;
        counter++;
    }
    return power;
}

/** 
 * @brief Finds the maximum element in a square matrix.
 * 
 * 4. Quadratic Time – Square Matrix Max Element: Write a function to find the 
 * maximum element in a square matrix (number of rows == number of columns) of 
 * integers. The function should accept a reference to the matrix and the size N.
 * N will represent both the number of columns and number of rows. Analyze its 
 * time complexity, and discuss in detail why it is O(n^2). Ensure that the plot 
 * aligns with quadratic time.
 * 
 * Function generated by Copilot 09/10/2025, edited by Alex Burdick
 */
int findMaxInMatrix(int** matrix, int N, unsigned int& counter) {
    int maxElement = matrix[0][0]; // Assume the first element is the maximum
    for (int i = 0; i < N; i++) { // Loop through rows
        for (int j = 0; j < N; j++) { // Loop through columns
            if (matrix[i][j] > maxElement) {
                maxElement = matrix[i][j]; // Update max if current element is greater
            }
            counter++; // Increment counter for the operation
        }
    }
    return maxElement; // Return the maximum element found
}

/** 
 * @brief Calculates the factorial of a number iteratively.
 * 
 * 5. Linear Time - Factorials: Write an iterative function to calculate the 
 * factorials of a number, not including 1 and itself. It must be O(n). Analyze 
 * its time complexity and discuss why it is O(n). Ensure that the plot aligns 
 * with linear time.
 */
unsigned long long factorial(unsigned int n, unsigned int& counter) {
    unsigned long result = 1; /**< Holds the factorial to return */    
    while (n > 1) { // While n is greater than 1
        result *= n; // Multiply result by n
        n--; // Decrement n
        counter++; // Increment counter for the operation
    }
    return result; 
}

/** 
 * @brief Determines if a number is prime using trial division up to the square root of N.
 * 
 * 6. Linear (or Better?) - Prime Numbers: Using the concept of “trial division” 
 * write a function that implements an iterative solution to determine if any 
 * number N is prime. Analyze and discuss the time complexity of this approach. 
 * Implement the strategy that cuts trial division off at the square root of N. 
 * Analyze and discuss the time complexity of this approach. Graph both.
 */
bool isPrime(unsigned int N, unsigned int& counter) {
    for (int i = 2; i <= N/2; i++) { // Check for factors from 2 to N/2
        if (N % i == 0) {
            counter++; // Increment counter for the operation
            return false; // Found a factor, not prime
        }
    }
    return true; // No factors found, it is prime
}

/** 
 * @brief Checks if an array contains any duplicate items.
 * 
 * 7. Quadratic Time – Array has duplicates?: Write a boolean function that 
 * determines if an arraycontains any duplicate items. Provide a detailed 
 * analysis of the time complexity and discuss why it is O(n^2). Ensure that the 
 * plot aligns with quadratic time.
 */
bool hasDuplicates(int* arr, int size, unsigned int& counter) {
    for (int i = 0; i < size; i++) {
        for (int j = i + 1; j < size; j++) {
            if (arr[i] == arr[j]) {
                counter++; // Increment counter for the operation
                return true; // Found a duplicate
            }
        }
    }
    return false; // No duplicates found
}