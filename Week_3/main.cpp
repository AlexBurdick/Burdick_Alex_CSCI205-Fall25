/************************************************************************
 * @file  main.cpp
 * 
 * @brief The main function for the analysis homework project. This file
 * contains the main function that calls various analysis functions and
 * writes their results to text files.
 ************************************************************************/

#include <iostream>
#include <fstream>
#include <ctime>

using namespace std;

/** 
 * @brief Finds the middle element of an array.
 * 
 * @param arr The array of integers.
 * @return int The middle element of the array.
 *
 * 1. Constant Time – Array Middle Element: Write a C++ function that takes an 
 * array of integers and returns the middle element. Analyze the time complexity 
 * and discuss why it is O(1). Ensure that the plot aligns with constant time.
 */
int getMiddleElement(int arr[], int size) {
    return arr[size / 2]; // Return the middle element
    /**
    if (size % 2 == 0) {
        return arr[(size / 2) - 1]; // Return lower middle for even-sized arrays
    } else {
        return arr[size / 2]; // Return middle element for odd-sized arrays
    }
    */
}

/** 
 * @brief Finds the range of elements in an array.
 * 
 * @param arr The array of integers.
 * @param size The size of the array.
 * @return int The range of the array (max - min).
 * 
 * 2. Linear Time – Array Range: Implement a function to find the range of all 
 * elements in an array of integers using a loop. Analyze its time complexity 
 * and discuss why it is O(n). Ensure that the plot aligns with linear time.
 * 
 * Function generated by Copilot 09/10/2025, edited by Alex Burdick
 */
int findRange(int arr[], int size) {
    if (size <= 0) return 0; // Handle empty array case

    int min = arr[0]; /**< Holder for the smallest number. */
    int max = arr[0]; /**< Holder for the largetst number */

    for (int i = 1; i < size; i++) {        // Loop through the array and set 
        if (arr[i] < min) { min = arr[i]; } // the min and max, starting at 1
        if (arr[i] > max) { max = arr[i]; } // because we already set min and 
    }                                       // max to arr[0]

    return max - min; // Return the range
}

/**
 * @brief Calculates the power of a number using iterative multiplication.
 * 
 * 3. Linear Time - Exponential Function: Implement an iterative function to 
 * calculate the result of raising a number to a power (e.g., x^n). Do not use 
 * any library exponentiation, use brute force iterative multiplication. 
 * Analyze and discuss its time complexity. Ensure that the plot aligns with 
 * your conclusions.
 */
unsigned long powerOfN(int base, int exponent, unsigned int& counter) {
    unsigned long power = base;
    
    for (int i = 2; i <= exponent; i++) { // Start at 2, we already have base^1
        power *= base;
        counter++;
    }

    return power;
}

/** 
 * @brief Finds the maximum element in a square matrix.
 * 
 * 4. Quadratic Time – Square Matrix Max Element: Write a function to find the 
 * maximum element in a square matrix (number of rows == number of columns) of 
 * integers. The function should accept a reference to the matrix and the size N.
 * N will represent both the number of columns and number of rows. Analyze its 
 * time complexity, and discuss in detail why it is O(n^2). Ensure that the plot 
 * aligns with quadratic time.
 * 
 * Function generated by Copilot 09/10/2025, edited by Alex Burdick
 */
int findMaxInMatrix(int (&matrix)[3][3], int N) {
    int maxElement = matrix[0][0]; // Assume the first element is the maximum

    for (int i = 0; i < N; i++) { // Loop through rows
        for (int j = 0; j < N; j++) { // Loop through columns
            if (matrix[i][j] > maxElement) {
                maxElement = matrix[i][j]; // Update max if current element is greater
            }
        }
    }

    return maxElement; // Return the maximum element found
}

/** 
 * @brief Calculates the factorial of a number iteratively.
 * 
 * 5. Linear Time - Factorials: Write an iterative function to calculate the 
 * factorials of a number, not including 1 and itself. It must be O(n). Analyze 
 * its time complexity and discuss why it is O(n). Ensure that the plot aligns 
 * with linear time.
 */
unsigned long factorial(unsigned int n) {
    unsigned long result = 1; /**< Holds the factorial to return */    
    while (n > 1) { // While n is greater than 1
        result *= n; // Multiply result by n
        n--; // Decrement n
    }
    
    /** 
    for (int i = 2; i <= n; i++) { // Start from 2 to n
        result *= i; // Multiply result by i
    } */

    return result; 
}

/** 
 * @brief Determines if a number is prime using trial division up to the square root of N.
 * 
 * 6. Linear (or Better?) - Prime Numbers: Using the concept of “trial division” 
 * write a function that implements an iterative solution to determine if any 
 * number N is prime. Analyze and discuss the time complexity of this approach. 
 * Implement the strategy that cuts trial division off at the square root of N. 
 * Analyze and discuss the time complexity of this approach. Graph both.
 * 
 * Function generated by Copilot 09/10/2025, edited by Alex Burdick
 */
bool isPrime(unsigned int N) {
    if (N <= 1) return false; // Numbers less than or equal to 1 are not prime
    if (N <= 3) return true; // 2 and 3 are prime numbers

    if (N % 2 == 0 || N % 3 == 0) return false; // Eliminate multiples of 2 and 3

    for (int i = 5; i * i <= N; i += 6) { // Check for factors from 5 to sqrt(N)
        if (N % i == 0 || N % (i + 2) == 0) {
            return false; // Found a factor, not prime
        }
    }
    return true; // No factors found, it is prime
}

/** 
 * @brief Checks if an array contains any duplicate items.
 * 
 * 7. Quadratic Time – Array has duplicates?: Write a boolean function that 
 * determines if an arraycontains any duplicate items. Provide a detailed 
 * analysis of the time complexity and discuss why it is O(n^2). Ensure that the 
 * plot aligns with quadratic time.
 * 
 * Function generated by Copilot 09/10/2025, edited by Alex Burdick
*/
bool hasDuplicates(int arr[], int size) {
    for (int i = 0; i < size; i++) { // Outer loop
        for (int j = i + 1; j < size; j++) { // Inner loop
            if (arr[i] == arr[j]) {
                return true; // Found a duplicate
            }
        }
    }
    return false; // No duplicates found
}

void experiment()
{
    /**
     * Call each function and write the results to text files
     */
    ofstream constantTimeFile("Constant_Time.txt");
    ofstream linearTimeFile("Linear_Time.txt");
    ofstream quadraticTimeFile("Quadratic_Time.txt");
    ofstream linearBetterFile("Linear_Better_Time.txt");
    ofstream factorialFile("Factorial_Time.txt");
    ofstream primeFile("Prime_Time.txt");
    ofstream duplicatesFile("Duplicates_Time.txt");

    // How many times to run the experiment
    int n = 2;
    const unsigned LIMIT = 100;
    for(int i = 0; i < LIMIT; i++)
    {
        // Call each function here and write results to the appropriate file
        // Example: constantTimeFile << getMiddleElement(...) << endl;
        // Middle element
        unsigned int counter = 0;
        int arr[] = {1,2,3,4,5};
        int result = getMiddleElement(arr, sizeof(arr)/sizeof(arr[0]));
        constantTimeFile << i << " " << counter << "/n";

        counter = 0;
        result = powerOfN(n, i, counter);
        linearBetterFile << i << " " << counter << "/n";
    }
}

int main()
{
    // Testing functions
    // Middle element
    unsigned int counter = 0;
    int arr[] = {1,2,3,4,5};
    int size = sizeof(arr)/sizeof(arr[0]);
    int middle = getMiddleElement(arr, size);
    cout << "Middle element: " << middle << "/n";

    // Range
    counter = 0;
    int range = findRange(arr, size);
    cout << "Range: " << range << "/n";

    // Power
    counter = 0;
    int base {2}, exponent {10};
    unsigned long power = powerOfN(base, exponent, counter);
    cout << base << "^" << exponent << " = " << power << "/n";

    // Matrix max
    int N = 3;
    int matrix[3][3] = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };
    int max = findMaxInMatrix(matrix, N);
    cout << "Max in matrix: " << max << "/n";
    
    // Factorial
    counter = 0;
    int num = 5;
    unsigned long fact = factorial(num);
    cout << num << "! = " << fact << "/n";

    
    //experiment();
    return 0;
}