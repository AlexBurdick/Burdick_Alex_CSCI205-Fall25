#ifndef FRACTION_H
#define FRACTION_H

/*********************************************************************
 * @file  Fraction.h
 * 
 * @brief Fraction class.
 *********************************************************************/
#include <iostream>

/**
 * Fraciton class generated by Copilot and edited 08/27/2025
 */
class Fraction {
private:
    int m_numerator, m_denominator; /**< Top and bottom numeber of Fraction */

    void simplify()
    {
        // Reduce the fraction
        int divisor = gcd(m_numerator, m_denominator);
        m_numerator /= divisor;
        m_denominator /= divisor;
        
        // Ensure the denominator is always positive
        if (m_denominator < 0) // This will also work if the numerator is negative too
        {
            m_numerator = -m_numerator;
            m_denominator = -m_denominator;
        }
    }

public:
    // ------------------------------
    // CONSTRUCTORS
    // ------------------------------
    /**
     * @brief No argument constructor for a new Fraction object
     */
    Fraction();

    /**
     * @brief Construct a new Fraction object
     * 
     * @param n numerator
     * @param d denominator
     */
    Fraction(int n, int d);

    // ------------------------------
    // ACCESSORS & MUTATORS
    // ------------------------------
    /**
     * @brief Get the numerator
     * 
     * @return int 
     */
    int get_num() const { return m_numerator; }

    /**
     * @brief Get the denominator
     * 
     * @return int 
     */
    int get_den() const { return m_denominator; }


    // ------------------------------
    // OVERLOADED OPERATORS
    // ------------------------------
    /**
     * @brief Overloaded + operator
     * 
     * @param other Fraction
     * @return Fraction
     * Overloaded arithmetic operators are member funcitons to improve 
     * performance when accessing member variables. Because both operands 
     * (left is implicit *this) are Fractions, it doesn't matter which
     * order the operands are in, making it user friendly to make them 
     * member functions.
     */
    Fraction operator+(const Fraction& other) const;

    /**
     * @brief Overloaded - operator
     * 
     * @param other 
     * @return Fraction 
     */
    Fraction operator-(const Fraction& other) const;
    
    /**
     * @brief Overloaded * operator
     * 
     * @param other 
     * @return Fraction 
     */
    Fraction operator*(const Fraction& other) const;
    
    /**
     * @brief Overloaded / operator
     * 
     * @param other 
     * @return Fraction 
     */
    Fraction operator/(const Fraction& other) const;
    
    /**
     * @brief Overloaded += operator
     * 
     * @param other 
     * @return Fraction
     * Overloaded compound assigment operators are member functions and not const
     * as they will need to modify the object calling them.
     */
    Fraction operator+=(const Fraction& other);

    // Overloaded comparison operators (created by Copilot 08/27/2025)
    bool operator==(const Fraction& other) const
    { return m_numerator == other.m_numerator && m_denominator == other.m_denominator; }
    
    bool operator!=(const Fraction& other) const 
    { return !(*this == other); }
    
    bool operator<(const Fraction& other) const
    { return m_numerator * other.m_denominator < other.m_numerator * m_denominator; }
    
    bool operator<=(const Fraction& other) const
    { return *this < other || *this == other; }
    
    bool operator>(const Fraction& other) const
    { return !(*this <= other); }
    
    bool operator>=(const Fraction& other) const 
    { return !(*this < other); }
    
    /**
     * @brief Overloaded << operator
     * 
     * @return std::ostream&
     * The overloaded output operator is a friend function to have access to
     * mamber variables for better performance. It is not a member function
     * since the left operand of IO operators must be a stream object, therfore
     * cannot be *this as would be the case if it were a memeber function.
     */
    friend std::ostream& operator<<(std::ostream&, const Fraction&);

    // Utility functions
    int gcd(int, int);
};

// ------------------------------
// PROTOTYPE OVERLOADED OPERATORS
// ------------------------------
/** 
/**
 * @brief Overloaded + operator
 * 
 * @param other Fraction
 * @return Fraction
 * Overloaded arithmetic operators that work on a Fraction obejct and an integer.
 * These are not member fucntions so that they can be invoked in either order - 
 * If these were member functions, Fraction + 5 would work, but 5 + Fraction 
 * would not work since the implied left operand would have to be the oject of 
 * the class.
 */
// Fraction operator+(const Fraction& other) const;



#endif // FRACTION_H