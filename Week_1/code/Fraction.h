#ifndef FRACTION_H
#define FRACTION_H

/*********************************************************************
 * @file  Fraction.h
 * 
 * @brief Fraction class.
 * Author: Alex Burdick
 * Fraciton class generated by Copilot and edited 08/27/2025
 *********************************************************************/
#include <iostream>

class Fraction {
private:
    int m_numerator, m_denominator; /**< Top and bottom numeber of Fraction */

    void simplify()
    {
        // Reduce the fraction
        int divisor = gcd(m_numerator, m_denominator);
        m_numerator /= divisor;
        m_denominator /= divisor;
        
        // Ensure the denominator is always positive
        if (m_denominator < 0) // This works if the numerator is negative too
        {
            m_numerator = -m_numerator;
            m_denominator = -m_denominator;
        }
    }

public:
    // ------------------------------
    // CONSTRUCTORS
    // ------------------------------
    /**
     * @brief No argument constructor for a new Fraction object
     */
    Fraction();

    /**
     * @brief Construct a new Fraction object
     * 
     * @param n numerator
     * @param d denominator
     */
    Fraction(int n, int d);

    // ------------------------------
    // ACCESSORS
    // ------------------------------
    /**
     * @brief Get the numerator
     * 
     * @return int 
     */
    int get_num() const { return m_numerator; }

    /**
     * @brief Get the denominator
     * 
     * @return int 
     */
    int get_den() const { return m_denominator; }


    // ------------------------------
    // OVERLOADED OPERATORS
    // ------------------------------
    /**
     * @brief Overloaded + operator
     * 
     * @param other Fraction
     * @return Fraction
     * Overloaded arithmetic operators are member funcitons to improve 
     * performance when accessing member variables. Because both operands 
     * (left is implicit *this) are Fractions, it doesn't matter which
     * order the operands are in, making it user friendly to make them 
     * member functions.
     */
    Fraction operator+(const Fraction& other) const;

    /**
     * @brief Overloaded - operator
     * 
     * @param other 
     * @return Fraction 
     */
    Fraction operator-(const Fraction& other) const;
    
    /**
     * @brief Overloaded * operator
     * 
     * @param other 
     * @return Fraction 
     */
    Fraction operator*(const Fraction& other) const;
    
    /**
     * @brief Overloaded / operator
     * 
     * @param other 
     * @return Fraction 
     */
    Fraction operator/(const Fraction& other) const;
    
    /**
     * @brief Overloaded += operator
     * 
     * @param other 
     * @return Fraction
     * Overloaded compound assigment operators are member functions and not const
     * as they will need to modify the object calling them.
     */
    Fraction operator+=(const Fraction& other);
    
    // Overloaded comparison operators (created by Copilot 08/27/2025, edited by author)
    /**
     * @brief Overloaded == operator
     * 
     * @param Fraction other to be compared to 
     * @return true or false
     */
    bool operator==(const Fraction& other) const
    { return m_numerator == other.m_numerator && m_denominator == other.m_denominator; }
    
    /**
     * @brief Overloaded != operator
     * 
     * @param Fraction other to be compared to 
     * @return true or false
     */
    bool operator!=(const Fraction& other) const 
    { return !(*this == other); }
    
    /**
     * @brief Overloaded < operator
     * 
     * @param Fraction other to be compared to 
     * @return true or false
     */
    bool operator<(const Fraction& other) const
    { return m_numerator * other.m_denominator < other.m_numerator * m_denominator; }
    
    /**
     * @brief Overloaded <= operator
     * 
     * @param Fraction other to be compared to 
     * @return true or false
     */
    bool operator<=(const Fraction& other) const
    { return *this < other || *this == other; }
    
    /**
     * @brief Overloaded > operator
     * 
     * @param Fraction other to be compared to 
     * @return true or false
     */
    bool operator>(const Fraction& other) const
    { return !(*this <= other); }
    
    /**
     * @brief Overloaded >= operator
     * 
     * @param Fraction other to be compared to 
     * @return true or false
     */
    bool operator>=(const Fraction& other) const 
    { return !(*this < other); }
    
    /**
     * @brief Overloaded << operator
     * 
     * @return std::ostream&
     * @details The overloaded output operator is a friend function to have 
     * access to mamber variables for better performance. It is not a member 
     * function since the left operand of IO operators must be a stream object, 
     * therfore cannot be *this as would be the case if it were a memeber function.
     */
    friend std::ostream& operator<<(std::ostream&, const Fraction&);

    // Utility functions
    int gcd(int, int);
};

#endif // FRACTION_H