/* g++ -g -Wall -pedantic -o a.out *.cpp *.hpp *.h
 * valgrind --tool=memcheck --leak-check=full ./a.out
 */

#include <iostream>
#include <fstream>
#include <string>
#include "LinearHashTable.hpp"
#include "QuadHashTable.hpp"
#include "ClosedHashTable.hpp"
#include "Contact.h"

using namespace std;

// Function prototypes
void testLinearOpen();
void testQuadOpen();
void testClosed();
void graphTests();

int main() {
    // testLinearOpen(); // Test object Contact data type, uses lengthDependent and division hash
    // testQuadOpen(); // Test char data type, uses digitAnalysis hash
    testClosed(); // Test float data type, uses midSquare hash
    // graphTests();
}

void graphTests() {

    // Delcare a test limit
    unsigned int LIMIT = 100;
    int counter = 0; // counter for operations
    string base = "key_";
    // how to use counter: V value = ht.get(key, &counter);

    // Create files for graphing
    ofstream quadPut("quadPut.txt");
    ofstream quadGet("quadGet.txt");
    ofstream quadRem("quadRem.txt");
    ofstream linearPut("linearPut.txt");
    ofstream linearGet("linearGet.txt");
    ofstream linearRem("linearRem.txt");
    ofstream closedPut("closedPut.txt");
    ofstream closedGet("closedGet.txt");
    ofstream closedRem("closedRem.txt");
    
    for (int i = 0; i < LIMIT; i++) {
        string key = base + to_string(i);
        QuadHashMap<int> qhm(i);

        // Get
        counter = 0; // reset counter
        qhm.put(key, i, &counter);
        quadPut << qhm.size() << " " << counter << "\n";

        // Put
        
        // Rem
    }
    
    //system("python grapher.py");

}

void testQuadOpen() {
    QuadHashMap<int> qhm(10); 
    string testStrings[] = {
        "a", "b", "c", "d", "e",
        "apple", "banana", "cherry", "date", "elderberry",
        "strawberry", "watermelon", "pineapple", "blueberry", "raspberry",
        "cat", "car", "cart", "caterpillar", "category",
        "dog", "door", "dorm", "dragon", "dragonfruit",
        "aaa", "bbb", "ccc", "ddd", "eee",
    };
    int numStrings = sizeof(testStrings) / sizeof(testStrings[0]); // from LeChat 10/18/2025
    char testChars[] = {
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
        'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
        'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3'
    };

    cout << "\nTesting put -\n";
    for (int i = 0; i < numStrings; i++) {
        qhm.put(testStrings[i], testChars[i]); // Insert each string with a dummy value
    }
    qhm.print();

    // Test contains and get
    cout << "\nTesting contains and get -\n";
    for (int i = 0; i < numStrings; i++) {
        if ( qhm.contains(testStrings[i]) ) {
            cout << "Found " << testStrings[i] << " = " << qhm.get(testStrings[i]);
        }
    }
    
    cout << "\nTesting remove -\n";
    for (int i = 0; i < numStrings; i++) {
        if (qhm.remove(testStrings[i])) {
            cout << "Removed: " << testStrings[i] << endl;
        }
    }

    // Test subscript operator
    cout << "\nTesting subscript operator\n";
    try {
        string key = "apple";
        cout << "Value for '" << key << "': " << qhm[key] << endl;
    } catch (const runtime_error& e) {
        cerr << e.what() << endl;
    }

    // Test size and empty
    cout << "\nTest size and empty\n";
    cout << "Size of hash table: " << qhm.size() << endl;
    cout << "Is hash table empty? " << (qhm.empty() ? "Yes" : "No") << endl;
}

void testLinearOpen() { // Generated by LeChat, 10/19/2025
    // Test data: keys and Contact objects
    string testKeys[]
     = {
        "alice", "bob", "charlie", "dave", "eve",
        "frank", "grace", "hank", "ivy", "jack"
    };
    Contact testContacts[] = {
        Contact("Alice Smith", "alice@example.com", "123-456-7890"),
        Contact("Bob Johnson", "bob@example.com", "234-567-8901"),
        Contact("Charlie Brown", "charlie@example.com", "345-678-9012"),
        Contact("Dave Wilson", "dave@example.com", "456-789-0123"),
        Contact("Eve Davis", "eve@example.com", "567-890-1234"),
        Contact("Frank Miller", "frank@example.com", "678-901-2345"),
        Contact("Grace Lee", "grace@example.com", "789-012-3456"),
        Contact("Hank Garcia", "hank@example.com", "890-123-4567"),
        Contact("Ivy Patel", "ivy@example.com", "901-234-5678"),
        Contact("Jack Robinson", "jack@example.com", "012-345-6789")
    };

    int numTests = sizeof(testKeys) / sizeof(testKeys[0]);

    // Create an OpenHashTable with string keys and Contact values
    LinearHashTable<Contact> contactHT(numTests);

    // Test insertion
    cout << "=== Testing OpenHashTable with Contact values ===\n";
    cout << "Inserting contacts...\n";
    for (int i = 0; i < numTests; ++i) {
        contactHT.put(testKeys[i], testContacts[i]);
        cout << "Inserted: Key=" << testKeys[i] << ", Value=" << testContacts[i] << endl;
    }

    // Print the hash table after insertion
    cout << "\nHash Table after insertion:\n";
    contactHT.print();

    // Test retrieval
    cout << "\nTesting retrieval:\n";
    for (int i = 0; i < numTests; ++i) {
        try {
            Contact contact = contactHT.get(testKeys[i]);
            cout << "Retrieved: Key=" << testKeys[i] << ", Value=" << contact << endl;
        } catch (const runtime_error& e) {
            cerr << "Error retrieving " << testKeys[i] << ": " << e.what() << endl;
        }
    }

    // Test contains
    cout << "\nTesting contains:\n";
    for (int i = 0; i < numTests; ++i) {
        bool found = contactHT.contains(testKeys[i]);
        cout << "Contains " << testKeys[i] << ": " << (found ? "Yes" : "No") << endl;
    }

    // Test update
    cout << "\nTesting update:\n";
    Contact updatedContact("Alice Smith Updated", "alice.updated@example.com", "111-222-3333");
    contactHT.put(testKeys[0], updatedContact);
    cout << "Updated: Key=" << testKeys[0] << ", New Value=" << updatedContact << endl;
    cout << "Retrieved after update: " << contactHT.get(testKeys[0]) << endl;

    // Test removal
    cout << "\nTesting removal:\n";
    string keysToRemove[] = {"bob", "eve", "hank"};
    for (int i = 0; i < 3; ++i) {
        bool removed = contactHT.remove(keysToRemove[i]);
        cout << "Removed " << keysToRemove[i] << ": " << (removed ? "Success" : "Failed") << endl;
    }

    // Print the hash table after removal
    cout << "\nHash Table after removal:\n";
    contactHT.print();

    // Test size and empty
    cout << "\nSize of hash table: " << contactHT.size() << endl;
    cout << "Is hash table empty? " << (contactHT.empty() ? "Yes" : "No") << endl;

    // Test non-existent key
    cout << "\nTesting non-existent key:\n";
    try {
        Contact contact = contactHT.get("nonexistent");
        cout << "Retrieved non-existent key (unexpected): " << contact << endl;
    } catch (const runtime_error& e) {
        cout << "Caught expected exception for non-existent key: " << e.what() << endl;
    }
}

void testClosed() {

    // Tests suggested by LeChat, modified by author (10/19/2025)
    ClosedHashTable<float> ht(5);
    string testStrings[] = {"apple", "banana", "cherry", "date", "elderberry", "fig", "grape"};
    float testFloats[] = {37.2614f, 12.8439f, 95.6721f, 44.5005f, 78.3294f, 5.1234f, 66.6667f};
    int numStrings = sizeof(testStrings) / sizeof(testStrings[0]); // from LeChat 10/18/2025

    // Test put
    cout << "Testing put-\n";
    for (int i = 0; i < numStrings; ++i) {
        ht.put(testStrings[i], testFloats[i]);
    }
    cout << "\nHash Table after insertion\n" << endl;
    ht.print();

    // Test get
    cout << "\nTesting get-\n";
    for (int i = 0; i < 7; ++i) {
        try {
            int val = ht.get(testStrings[i]);
            cout << "Key: " << testStrings[i] << " = " << val << endl;
        } catch (const runtime_error& e) {
            cerr << e.what() << endl;
        }
    }

    // Test contains
    cout << "\nTesting contains-\n";
    for (int i = 0; i < numStrings; i++) {
        if ( ht.contains(testStrings[i]) ) {
            cout << "Found " << testStrings[i] << " = " << ht.get(testStrings[i]);
        }
    }

    // Test remove
    cout << "\nTesting remove-\n";
    string keysToRemove[] = {"banana", "date", "kiwi"};
    for (int i = 0; i < 3; i++) {
        bool removed = ht.remove(keysToRemove[i]);
        cout << keysToRemove[i] << " : " << (removed ? "Success" : "Failed") << endl;
    }
    ht.print();

    // Test subscript operator
    cout << "\nTesting subscript operator\n";
    try {
        string key = "apple";
        cout << "Value for '" << key << "': " << ht[key] << endl;
    } catch (const runtime_error& e) {
        cerr << e.what() << endl;
    }

    // Test size and empty
    cout << "\nTest size and empty\n";
    cout << "Size of hash table: " << ht.size() << endl;
    cout << "Is hash table empty? " << (ht.empty() ? "Yes" : "No") << endl;
}